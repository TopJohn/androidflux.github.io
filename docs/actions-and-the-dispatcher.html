<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Flux | Application Architecture for Building User Interfaces</title><meta name="viewport" content="width=device-width"><meta property="og:title" content="Flux | Application Architecture for Building User Interfaces"><meta property="og:type" content="website"><meta property="og:url" content="http://facebook.github.io/flux/index.html"><meta property="og:description" content="Application Architecture for Building User Interfaces"><link rel="stylesheet" href="/css/flux.css"><script type="text/javascript" src="//use.typekit.net/vqa1hcx.js"></script><script type="text/javascript">try{Typekit.load();}catch(e){}</script></head><body><div class="container"><div class="nav-main"><div class="wrap"><a class="nav-home" href="/"><img class="nav-logo" src="/img/flux_logo.svg" width="50" height="50">AndroidFlux</a><ul class="nav-site"><li><a href="/docs/overview.html#content" class="active">docs</a></li><li><a href="/support.html" class="">support</a></li><li><a href="https://github.com/androidflux/androidflux.github.io" class="">github</a></li></ul></div></div><section class="content wrap documentationContent"><div class="nav-docs"><div class="nav-docs-section"><h3>Quick Start</h3><ul><li><a style="margin-left:0;" class="" href="/docs/overview.html#content">AndroidFlux一览</a></li><li><a style="margin-left:0;" class="" href="/docs/helloworld.html#content">Tutorial - Hello World</a></li><li><a style="margin-left:0;" class="" href="/docs/todo-list.html#content">Tutorial – Todo List</a></li><li><a style="margin-left:0;" class="" href="/docs/chat.html#content">Tutorial – Chat</a></li></ul></div><div class="nav-docs-section"><h3>Guides</h3><ul><li><a style="margin-left:0;" class="" href="/docs/async-task-and-network.html#content">异步操作和网络</a></li><li><a style="margin-left:0;" class="" href="/docs/store-and-data-persistence.html#content">Stores和数据存储</a></li><li><a style="margin-left:0;" class="active" href="/docs/actions-and-the-dispatcher.html#content">Actions和Dispatcher</a></li><li><a style="margin-left:0;" class="" href="/docs/testing-flux-applications.html#content">Testing Flux Applications</a></li></ul></div><div class="nav-docs-section"><h3>Reference</h3><ul><li><a style="margin-left:0;" class="" href="/docs/dispatcher.html#content">Dispatcher</a></li><li><a style="margin-left:0;" class="" href="/docs/flux-utils.html#content">Flux Utils</a></li></ul></div><div class="nav-docs-section"><h3>Community Resources</h3><ul><li><a style="margin-left:0;" class="" href="/docs/videos.html#content">Videos</a></li><li><a style="margin-left:0;" class="" href="/docs/examples-and-tools.html#content">Examples and Tools</a></li></ul></div><div class="nav-docs-section"><h3>Complementary</h3><ul><li><a target="_blank" style="margin-left:0;" class="" href="http://facebook.github.io/react/">React – UI Library</a></li><li><a target="_blank" style="margin-left:0;" class="" href="http://facebook.github.io/immutable-js/">ImmutableJS – Immutable Data</a></li><li><a target="_blank" style="margin-left:0;" class="" href="http://facebook.github.io/jest/">Jest – Unit Testing</a></li></ul></div></div><div class="inner-content"><a id="content"></a><h1>Actions和Dispatcher</h1><div><h2><a class="anchor" name="dispatcher"></a>Dispatcher <a class="hash-link" href="#dispatcher">#</a></h2><p><strong><em>Dispatcher</em></strong> 作为Flux应用中数据流的中转枢纽，采用单例模式。它的本质是注册回调接口，并且可以有序的调用它们。 每一个 <strong><em>Store</em></strong> 都在 <strong><em>Dispatcher</em></strong>中进行注册。 当新的数据进入到 <strong><em>Dispatcher</em></strong>中时，它（Dispatcher）会把数据发送给每一个 <strong><em>Stores</em></strong>。 通过 <code>dispatch()</code>方法把数据发送到各个Store，并且 <code>dispatch()</code>只有一个传送数据的对象(data-payload-object)作为参数，而它实际上就是Action。</p><div><figure class="diagram">
  <img src="/img/flux-simple-f8-diagram-with-client-action-1300w.png" alt="data flow in Flux with data originating from user interactions" width=650 />
</figure>

</div><h2><a class="anchor" name="actions-and-action-creators"></a>Actions and Action Creators <a class="hash-link" href="#actions-and-action-creators">#</a></h2><p>无论是用户与应用交互还是网络API的响应，当新的数据输入系统的时候， 这个数据被包装到 <strong><em>Action</em></strong> — 一个包含了数据和Action类型的对象。我们经常会创建一个类(ActionCreator)包含各种帮助方法，这些方法不仅创建<strong><em>Action</em></strong>，并且把Action传递给<strong><em>Dispatcher</em></strong>。</p><p><strong><em>Actions</em></strong>之间通过<code>type</code>属性进行区分。当所有<strong><em>Stores</em></strong>接收到<strong><em>Action</em></strong>时，就可以通过明确的<code>type</code>属性来判断是否处理和怎么处理传来的数据。在一个Flux应用中，<strong><em>Stores</em></strong>和<strong><em>Views</em></strong>都是自控制的，他们不会响应外部的对象。<strong><em>Actions</em></strong>通过<strong><em>Stores</em></strong>注册在Dispatcher中的回调接口获取，而不是通过<code>set</code>方法。</p><h2><a class="anchor" name="dispatcher"></a>为什么需要 Dispatcher <a class="hash-link" href="#dispatcher">#</a></h2><p>随着一个应用的成长，<strong><em>Stores</em></strong> 之间的依赖是常有的事。StoreA要等到StoreB先更新，所以StoreA应该知道自己什么时候更新，这种情况是不可避免的。我们需要通过<strong><em>Dispatcher</em></strong>先调用StoreB的回调，并在回调结束后再去调用StoreA。为了明确的声明依赖关系，一个<strong><em>Store</em></strong> 需要明确的告诉<strong><em>Dispatcher</em></strong>，“我需要等到StoreB把Action处理完再执行。” 因此<strong><em>Dispatcher</em></strong> 通过提供<code>waitFor()</code> 方法来实现这个功能。</p><p><code>dispatch()</code> 方法提供回调方法的同步遍历，按顺序的调用回调。当<code>waitFor()</code>遇到了回调中的某一个时， 当前执行的回调将被停止并且 <code>waitFor()</code> 会提供给我们一个基于依赖的新的遍历循环。 当全部的依赖被执行完时，原先的callback才会继续被执行。</p><p>另外，在同一个Store的回调方法里，<code>waitFor()</code> 方法可以根据Action的不同类型按不同的方式使用。例如在一种情况下StoreA要等待Store B的执行，但在其他场景下，StoreA可能要等待StoreC的执行。根据Action的类型，在每种<code>switch-case</code>的代码块里面调用<code>waitFor()</code> 可以解决细粒度的依赖控制。</p><p>当存在循环依赖时，会导致问题产生。 比如，StoreA 需要等待StoreB同时StoreB需要等待StoreA，我们将陷于死循环。所以在创建Dispatcher的时候需要特别注意，并避免这个问题。</p><p><em>译: @JiangDaYa0 修订：@ntop001</em></p></div><div class="docs-prevnext"><a class="docs-next" href="testing-flux-applications.html#content">Next →</a></div></div></section><footer class="wrap"><div class="right">© 2014-2015 AndroidFlux.</div></footer></div><div id="fb-root"></div><script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
            ga('create', 'UA-387204-10', 'facebook.github.io');
            ga('send', 'pageview');

            !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)
            ){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";
            fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
          </script></body></html>